// Formal points over integers

load 'utils.magma';

// =================
// Parameters choice
// =================
k := 8; // nilpotence of X
selected_points := [7*391]; // Points to compute
modulo := 0; // If nonzero is added to the quotient
// Every point nP can be accessed after run via formal_points[n]


// ====
// Code
// ====
// We pick a generic curve
R<a1, a2, a3, a4, a6, X, Z, eps> := PolynomialRing(Integers(), 8);
if modulo ne 0 then
	I := ideal<R | X^k, Z^k, eps^k, modulo>;
else 
	I := ideal<R | X^k, Z^k, eps^k>;
end if;
Rk := R/I;

// Compute F such that for a generic point in \pi^{-1}(0) it holds Z = F(X)
right_side := -a1*X*Z - a3*Z^2 + X^3 + a2*X^2*Z + a4*X*Z^2 + a6*Z^3;
right_side := Rk!right_side;
F := right_side;
cnt := 0;

while true do 
	cnt +:= 1;
	print "F step", cnt;
	F2 := Evaluate(F, Z, right_side);
	if F2 eq F then break; end if;
	F := F2;
end while; 

// Take a generic point P = [X, 1, F(X)] and compute its multiples
formal_points := AssociativeArray();;
Frk := Rk!F;
P := [Rk!X, Rk!1, Frk];
formal_points[1] := P;

for i in selected_points do
	printf "----------\nCopmuting %oP\n", i;
	Q := formalMul(P, i);
	formal_points[i] := Q;
	printf "%oP : %o\n", i, Q[1];
end for;