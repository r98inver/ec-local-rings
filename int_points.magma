// Formal points over integers

load 'utils.magma';

// =================
// Parameters choice
// =================
k := 8; // nilpotence of X
n_sum := 11*13; // Number of points to compute
selected_points := [11*13]; // Index of points to show (only x coordinate) - can be empty
modulo := 0; // If nonzero is added to the quotient
// Every point nP can be accessed after run via formal_points[n]


// ====
// Code
// ====
// We pick a generic curve
R<a1, a2, a3, a4, a6, X, Z, eps> := PolynomialRing(Integers(), 8);
if modulo ne 0 then
	I := ideal<R | X^k, Z^k, eps^k, modulo>;
else 
	I := ideal<R | X^k, Z^k, eps^k>;
end if;
Rk := R/I;

// Compute F such that for a generic point in \pi^{-1}(0) it holds Z = F(X)
right_side := -a1*X*Z - a3*Z^2 + X^3 + a2*X^2*Z + a4*X*Z^2 + a6*Z^3;
right_side := Rk!right_side;
F := right_side;
cnt := 0;

while true do 
	cnt +:= 1;
	print "F step", cnt;
	F2 := Evaluate(F, Z, right_side);
	if F2 eq F then break; end if;
	F := F2;
end while; 

// Take a generic point P = [X, 1, F(X)] and compute its multiples
formal_points := [];
Frk := Rk!F;
P := [Rk!X, Rk!1, Frk];
Include(~formal_points, P);
Q := P;

for i in [1..n_sum] do
	print "Sum step", i;
	Q := formalAdd(P, Q);
	//print i, "Check: ", Q[3] eq Evaluate(Frk, Rk!X, Q[1]);
	Append(~formal_points, Q);
end for;
// Now we have the formal expression of a generic 2P, 3P...

for i in selected_points do
	printf "----------\n%oP : %o\n", i, formal_points[i][1];
end for;